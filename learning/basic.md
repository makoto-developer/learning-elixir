# Pattern match

`=`はElixirではマッチ演算子と呼ばれる。代入ではない。`x=1`でxを1に束縛したあと、`x`と`2`を束縛しようとするとエラーになる。

また、変数の束縛は1度しかできない(`[b, b] = [1, 2]`みたいなのはできない)。

Elixirで(というか関数型プログラミング全般で)おいて、`=`は今までのイコールとは意味を忘れなければならない。

```elixir
iex(4)> x = x
2
iex(5)> x = 1
1
iex(6)> 2 = x
** (MatchError) no match of right hand side value: 1
    (stdlib 4.3) erl_eval.erl:496: :erl_eval.expr/6
    iex:6: (file)

```

パターンマッチはいろいろなやり方がある。↓はリストの一部を取り出す。

```elixir
iex(6)> list = [ 1, 2, 3 ]
[1, 2, 3]
iex(7)> [ a, b, c ] = list
[1, 2, 3]
iex(8)> a
1
iex(9)> b
2
iex(10)> c
3
```

`_`を使って値を無視する。

```elixir
iex(12)> [t, _, _] = list
[1, 2, 3]
iex(13)> t
1
```

パターンマッチで変数を使いたい場合は`^`を使う(これはPhoenix/EctoでSelect文に関数の引数を埋め込む時とかに使ったりするので覚えておく)

```elixir
iex(14)> y = 9
9
iex(15)> [w, 9, 1] = [10, y, 1]
[10, 9, 1]
iex(16)> w
10
```

# 変数

Elixirでは基本的に変数は全て不変である。不変とは変数の値を書き換えることができない、変わることがないということが保証されている。

非効率な気もするが、従来のプログラミングの書き方の方が実は非効率だ。何か書き換えたり追加したくなったら、直接データを書き換えず、データを別の新しいデータを作る。

つまり、

```bash
a = [ 1, 2, 3 ]
a = [ 1, 2, 3, 4]
```

ではなく、次のように書く。

```elixir
a = [ 1, 2, 3 ]
b = [ a | 4 ]
```

こうすることで、元々の`a`を更新する処理(メモリを書き換える作業)を省き、`a`のメモリ領域と新たに`4`をメモリ確保した領域を繋げるだけで新しい変数bが生まれる。

つまり、既存の変数の全てもしくは一部を再利用して新たな変数を作ることができる。

ElixirではListは連結リストなので追加する場合は処理コストを低くできる。

変換を行う関数は、その新しいコピーを返すだけなのでとてもシンプルになる。

# 型


